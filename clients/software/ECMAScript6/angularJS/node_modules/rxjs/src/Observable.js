var _this = this;
var Subscriber_1 = require('./Subscriber');
var Subscription_1 = require('./Subscription');
var toSubscriber_1 = require('./util/toSubscriber');
var IfObservable_1 = require('./observable/IfObservable');
var ErrorObservable_1 = require('./observable/ErrorObservable');
var observable_1 = require('./symbol/observable');
var Observable = (function () {
    function Observable() {
        this._isScalar = false;
    }
    return Observable;
})();
exports.Observable = Observable;
{
    if (subscribe) {
        this._subscribe = subscribe;
    }
}
create: Function = function (subscribe) {
    return new Observable(subscribe);
};
lift(operator, Operator(), Observable < R > {
    const: observable = new Observable(),
    observable: .source = this,
    observable: .operator = operator,
    return: observable
}, subscribe(), Subscription_1.Subscription);
subscribe(observer, PartialObserver(), Subscription_1.Subscription);
subscribe(next ?  : function (value) { return void ; }, error ?  : function (error) { return void ; }, complete ?  : function () { return void ; });
Subscription_1.Subscription;
subscribe(observerOrNext ?  : PartialObserver( | (function (value) { return void ; }), error ?  : function (error) { return void ; }, complete ?  : function () { return void ; }), Subscription_1.Subscription, {
    const: (_a = this, operator = _a.operator, _a),
    const: sink = toSubscriber_1.toSubscriber(observerOrNext, error, complete),
    if: function (operator) {
        operator.call(sink, this.source);
    }, else: {
        sink: .add(this._trySubscribe(sink))
    },
    if: function (sink, syncErrorThrowable) {
        sink.syncErrorThrowable = false;
        if (sink.syncErrorThrown) {
            throw sink.syncErrorValue;
        }
    },
    return: sink
}, protected, _trySubscribe(sink, Subscriber_1.Subscriber(), TeardownLogic, {
    try: {
        return: this._subscribe(sink)
    }, catch: function (err) {
        sink.syncErrorThrown = true;
        sink.syncErrorValue = err;
        sink.error(err);
    }
}, forEach(next, function (value) { return void ; }, PromiseCtor ?  : typeof Promise), Promise < void  > {
    if: function () { } }, !PromiseCtor), {
    if: function (root, Rx) {
        if (Rx === void 0) { Rx =  && root.Rx.config && root.Rx.config.Promise; }
        PromiseCtor = root.Rx.config.Promise;
    }, else: , if: function (root, Promise) {
        PromiseCtor = root.Promise;
    }
});
if (!PromiseCtor) {
    throw new Error('no Promise impl found');
}
return new PromiseCtor(function (resolve, reject) {
    var subscription = _this.subscribe(function (value) {
        if (subscription) {
            try {
                next(value);
            }
            catch (err) {
                reject(err);
                subscription.unsubscribe();
            }
        }
        else {
            next(value);
        }
    }, reject, resolve);
});
_subscribe(subscriber, Subscriber_1.Subscriber(), TeardownLogic, {
    return: this.source.subscribe(subscriber)
}, static);
if ()
    : typeof IfObservable_1.IfObservable.create;
throw ;
typeof ErrorObservable_1.ErrorObservable.create;
[observable_1.$$observable]();
{
    return this;
}
var _a;
//# sourceMappingURL=Observable.js.map
var __extends = (this && this.__extends) || function (d, b) {
    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
    function __() { this.constructor = d; }
    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
};
var Observable_1 = require('../Observable');
var Action_1 = require('../scheduler/Action');
var tryCatch_1 = require('../util/tryCatch');
var errorObject_1 = require('../util/errorObject');
var AsyncSubject_1 = require('../AsyncSubject');
var BoundNodeCallbackObservable = (function (_super) {
    __extends(BoundNodeCallbackObservable, _super);
    function BoundNodeCallbackObservable(callbackFunc, selector, args, context, scheduler) {
        _super.call(this);
        this.callbackFunc = callbackFunc;
        this.selector = selector;
        this.args = args;
        this.context = context;
        this.scheduler = scheduler;
    }
    BoundNodeCallbackObservable.create = function (func, selector, scheduler) {
        if (selector === void 0) { selector = undefined; }
        return ;
        this;
        any, ;
        args: any[];
        Observable_1.Observable < T > {
            return: new BoundNodeCallbackObservable(func, selector, args, this, scheduler)
        };
    };
    BoundNodeCallbackObservable.prototype._subscribe = function (subscriber) {
        var callbackFunc = this.callbackFunc;
        var args = this.args;
        var scheduler = this.scheduler;
        var subject = this.subject;
        if (!scheduler) {
            if (!subject) {
                subject = this.subject = new AsyncSubject_1.AsyncSubject();
                var handler = ;
                this;
                any, ;
                innerArgs: any[];
                {
                    var source = handlerFn.source;
                    var selector = source.selector, subject_1 = source.subject;
                    var err = innerArgs.shift();
                    if (err) {
                        subject_1.error(err);
                    }
                    else if (selector) {
                        var result_1 = tryCatch_1.tryCatch(selector).apply(this, innerArgs);
                        if (result_1 === errorObject_1.errorObject) {
                            subject_1.error(errorObject_1.errorObject.e);
                        }
                        else {
                            subject_1.next(result_1);
                            subject_1.complete();
                        }
                    }
                    else {
                        subject_1.next(innerArgs.length === 1 ? innerArgs[0] : innerArgs);
                        subject_1.complete();
                    }
                }
                ;
                handler.source = this;
                var result = tryCatch_1.tryCatch(callbackFunc).apply(this.context, args.concat(handler));
                if (result === errorObject_1.errorObject) {
                    subject.error(errorObject_1.errorObject.e);
                }
            }
            return subject.subscribe(subscriber);
        }
        else {
            return scheduler.schedule(dispatch, 0, { source: this, subscriber: subscriber, context: this.context });
        }
    };
    return BoundNodeCallbackObservable;
})(Observable_1.Observable);
exports.BoundNodeCallbackObservable = BoundNodeCallbackObservable;
this;
Action_1.Action < DispatchState < T >> , state;
DispatchState();
{
    var self_1 = this;
    var source = state.source, subscriber = state.subscriber, context = state.context;
    var _a = source, callbackFunc = _a.callbackFunc, args = _a.args, scheduler = _a.scheduler;
    var subject = source.subject;
    if (!subject) {
        subject = source.subject = new AsyncSubject_1.AsyncSubject();
        var handler = ;
        this;
        any, ;
        innerArgs: any[];
        {
            var source_1 = handlerFn.source;
            var selector = source_1.selector, subject_2 = source_1.subject;
            var err = innerArgs.shift();
            if (err) {
                subject_2.error(err);
            }
            else if (selector) {
                var result_2 = tryCatch_1.tryCatch(selector).apply(this, innerArgs);
                if (result_2 === errorObject_1.errorObject) {
                    self_1.add(scheduler.schedule(dispatchError, 0, { err: errorObject_1.errorObject.e, subject: subject_2 }));
                }
                else {
                    self_1.add(scheduler.schedule(dispatchNext, 0, { value: result_2, subject: subject_2 }));
                }
            }
            else {
                var value = innerArgs.length === 1 ? innerArgs[0] : innerArgs;
                self_1.add(scheduler.schedule(dispatchNext, 0, { value: value, subject: subject_2 }));
            }
        }
        ;
        handler.source = source;
        var result = tryCatch_1.tryCatch(callbackFunc).apply(context, args.concat(handler));
        if (result === errorObject_1.errorObject) {
            subject.error(errorObject_1.errorObject.e);
        }
    }
    self_1.add(subject.subscribe(subscriber));
}
function dispatchNext(arg) {
    var value = arg.value, subject = arg.subject;
    subject.next(value);
    subject.complete();
}
function dispatchError(arg) {
    var err = arg.err, subject = arg.subject;
    subject.error(err);
}
//# sourceMappingURL=BoundNodeCallbackObservable.js.map
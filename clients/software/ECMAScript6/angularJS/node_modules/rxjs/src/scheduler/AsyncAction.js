var __extends = (this && this.__extends) || function (d, b) {
    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
    function __() { this.constructor = d; }
    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
};
var Action_1 = require('./Action');
var Subscription_1 = require('../Subscription');
var AsyncScheduler_1 = require('./AsyncScheduler');
var AsyncAction = (function (_super) {
    __extends(AsyncAction, _super);
    function AsyncAction() {
        _super.apply(this, arguments);
        this.pending = false;
    }
    return AsyncAction;
})(Action_1.Action);
exports.AsyncAction = AsyncAction;
void ;
{
    _super.call(this, scheduler, work);
}
schedule(state ?  : T, delay, number = 0);
Subscription_1.Subscription;
{
    if (this.closed) {
        return this;
    }
    this.state = state;
    this.pending = true;
    var id = this.id;
    var scheduler = this.scheduler;
    if (id != null) {
        this.id = this.recycleAsyncId(scheduler, id, delay);
    }
    this.delay = delay;
    this.id = this.id || this.requestAsyncId(scheduler, this.id, delay);
    return this;
}
requestAsyncId(scheduler, AsyncScheduler_1.AsyncScheduler, id ?  : any, delay, number = 0);
any;
{
    return root_1.root.setInterval(scheduler.flush.bind(scheduler, this), delay);
}
recycleAsyncId(scheduler, AsyncScheduler_1.AsyncScheduler, id, any, delay, number = 0);
any;
{
    if (delay !== null && this.delay === delay) {
        return id;
    }
    return root_1.root.clearInterval(id) && undefined || undefined;
}
execute(state, T, delay, number);
any;
{
    if (this.closed) {
        return new Error('executing a cancelled action');
    }
    this.pending = false;
    var error_1 = this._execute(state, delay);
    if (error_1) {
        return error_1;
    }
    else if (this.pending === false && this.id != null) {
        this.id = this.recycleAsyncId(this.scheduler, this.id, null);
    }
}
_execute(state, T, delay, number);
any;
{
    var errored = false;
    var errorValue = undefined;
    try {
        this.work(state);
    }
    catch (e) {
        errored = true;
        errorValue = !!e && e || new Error(e);
    }
    if (errored) {
        this.unsubscribe();
        return errorValue;
    }
}
_unsubscribe();
{
    var id = this.id;
    var scheduler = this.scheduler;
    var actions = scheduler.actions;
    var index = actions.indexOf(this);
    this.work = null;
    this.delay = null;
    this.state = null;
    this.pending = false;
    this.scheduler = null;
    if (index !== -1) {
        actions.splice(index, 1);
    }
    if (id != null) {
        this.id = this.recycleAsyncId(scheduler, id, null);
    }
}
//# sourceMappingURL=AsyncAction.js.map